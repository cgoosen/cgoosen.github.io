---
layout: post
status: publish
published: true
title: Using a certificate to encrypt credentials in automated PowerShell scripts
author:
  display_name: Chris
  login: chris
  email: chris@cgoosen.com
  url: http://www.cgoosen.com
author_login: chris
author_email: chris@cgoosen.com
author_url: http://www.cgoosen.com
wordpress_id: 1304
wordpress_url: http://www.cgoosen.com/?p=1304
date: '2015-02-24 09:00:00 +0000'
date_gmt: '2015-02-24 15:00:00 +0000'
categories:
- Exchange Server
- Office 365
- PowerShell
tags: []
comments:
- id: 258799
  author: Tim Pringle
  author_email: pringtef@upcmail.nl
  author_url: ''
  date: '2015-02-27 16:43:30 +0000'
  date_gmt: '2015-02-27 22:43:30 +0000'
  content: Really nice article Chris, looking forward to trying this out.
- id: 258802
  author: Dave Wyatt
  author_email: dlwyatt115@gmail.com
  author_url: http://davewyatt.wordpress.com
  date: '2015-02-27 17:14:24 +0000'
  date_gmt: '2015-02-27 23:14:24 +0000'
  content: "Hi Chris,\r\n\r\nYou might be interested in two options that make this
    easier.  In the v5 preview of PowerShell (and in PowerShell 4.0 on fully-patched
    Windows 8.1 / 2012 R2 computers), there are new cmdlets called Protect-CmsMessage
    and Unprotect-CmsMessage.  You give them a certificate and the data you want to
    encrypt / decrypt, and they take care of the rest (while producing standards-based
    CMS output to represent the encrypted data.)\r\n\r\nAlso, I wrote a module called
    ProtectedData (available on GitHub and PowerShellGet) which does much the same
    thing, but is compatible all the way back to PowerShell 2.0, and has a few other
    features that the CmsMessage cmdlets don't.  (However, its output is not the CMS
    standard format, which means there's little to no chance for cross-platform utility.)
    \ Under the hood, it does almost exactly what you're doing here, but the calling
    code is much simplified:\r\n\r\n$Cert = Get-ChildItem Cert:\\LocalMachine\\My
    | Where-Object {$_.Subject -like \"CN=PowerShell Automation*\"}\r\n\r\n# To encrypt:\r\nProtect-Data
    'MyPassword' -Certificate $Cert -SkipCertificateVerification | Export-Clixml .\\encrypted.xml\r\n\r\n#
    To decrypt:\r\nUnprotect-Data (Import-Clixml .\\encrypted.xml) -Certificate $Cert
    -SkipCertificateVerification"
- id: 258803
  author: Chris
  author_email: chris@cgoosen.com
  author_url: http://www.cgoosen.com
  date: '2015-02-27 18:54:50 +0000'
  date_gmt: '2015-02-28 00:54:50 +0000'
  content: Thanks Tim!
- id: 258804
  author: Chris
  author_email: chris@cgoosen.com
  author_url: http://www.cgoosen.com
  date: '2015-02-27 18:57:53 +0000'
  date_gmt: '2015-02-28 00:57:53 +0000'
  content: Thanks for the great info Dave.
- id: 259015
  author: Jason
  author_email: Jason@jayandem.com
  author_url: ''
  date: '2015-03-03 08:45:48 +0000'
  date_gmt: '2015-03-03 14:45:48 +0000'
  content: Really like this Chris. I can see some changes to my script cache over
    the coming days.
- id: 266217
  author: Using self-signed certificates for encryption | megamorf
  author_email: ''
  author_url: https://megamorf.wordpress.com/2016/03/03/using-self-signed-certificates-for-encryption/
  date: '2016-03-03 10:20:21 +0000'
  date_gmt: '2016-03-03 16:20:21 +0000'
  content: "[&#8230;] http://www.cgoosen.com/2015/02/using-a-certificate-to-encrypt-credentials-in-automated-powershell-sc&#8230;
    [&#8230;]"
- id: 271109
  author: SCOM / SCSM &ndash; Retrieve Decrypted RunAs Account Credentials
  author_email: ''
  author_url: http://www.hpservicemanager.cf/scom-scsm-retrieve-decrypted-runas-account-credentials/
  date: '2017-04-26 06:15:08 +0000'
  date_gmt: '2017-04-26 12:15:08 +0000'
  content: "[&#8230;] manner. There are many ways to do so, like exporting the credentials
    into XML (Export-CliXML) , using certificates , encrypting the credentials using
    a key and store it somewhere like here or maybe you could store [&#8230;]"
- id: 271695
  author: Powershell automation with certificate encrypted passwords &#8211; Blog
    in progress
  author_email: ''
  author_url: https://dzumretblog.wordpress.com/2017/07/13/powershell-automation-with-certificate-encrypted-passwords/
  date: '2017-07-13 06:06:15 +0000'
  date_gmt: '2017-07-13 12:06:15 +0000'
  content: "[&#8230;] You can read Chris Goosens entire post to create certificate
    template and import it to your machine running the script here: &#8220;Using a
    certificate to encrypt credentials in automated PowerShell scripts&#8221;. [&#8230;]"
- id: 272758
  author: Jefry
  author_email: jefryk@student.telkomuniversity.ac.id
  author_url: http://www.telkomuniversity.ac.id
  date: '2017-11-09 01:52:21 +0000'
  date_gmt: '2017-11-09 07:52:21 +0000'
  content: Great post. Can i share it?
- id: 272777
  author: Chris
  author_email: chris@cgoosen.com
  author_url: http://www.cgoosen.com
  date: '2017-11-14 11:17:51 +0000'
  date_gmt: '2017-11-14 17:17:51 +0000'
  content: Yes, please do!
- id: 275496
  author: Steve Tanti
  author_email: Steve@tanti.id.au
  author_url: ''
  date: '2018-10-09 01:17:22 +0000'
  date_gmt: '2018-10-09 07:17:22 +0000'
  content: "Excellent and thorough post, exactly what I was looking for!\r\n\r\nThanks!"
- id: 276167
  author: Branko Sabadi
  author_email: bsabadi@gmail.com
  author_url: ''
  date: '2018-11-12 05:16:25 +0000'
  date_gmt: '2018-11-12 11:16:25 +0000'
  content: "To answer why selfsigned with cmdlet New-SelfSignedCertificat won't work:\r\n\r\nPowerShell
    command New-SelfSignedCertificate won't work. It hardcodes the wrong crypto provider
    into the certs it generates. The wrong thing is that it's the provider of the
    \"key store\" type, and you won't be able to get the private key out of this certificate.
    Instead you need to generate the cert with the command makecert.exe that can be
    downloaded from MSDN as a part of Windows SDK (it will be in a location like C:\\Program
    Files (x86)\\Windows Kits\\8.1\\bin\\x64)\r\n\r\nSource:\r\nhttps://blogs.msdn.microsoft.com/sergey_babkins_blog/2015/11/06/certificates-part-2-encryption-and-decryption-and-some-about-the-cert-store/"
- id: 276175
  author: Chris
  author_email: chris@cgoosen.com
  author_url: http://www.cgoosen.com
  date: '2018-11-12 12:09:01 +0000'
  date_gmt: '2018-11-12 18:09:01 +0000'
  content: Thanks for the info Branko
- id: 276176
  author: Aaron Kenah
  author_email: ajkenah@yahoo.com
  author_url: ''
  date: '2018-11-12 17:26:56 +0000'
  date_gmt: '2018-11-12 23:26:56 +0000'
  content: I know this is an ancient post, but I wanted to provide some info as this
    post still rates high in Google.  To generate a self signed certificate that is
    complient with .Net and can be used by this solution you can use the "New-SelfSignedCertificate"
    Powershell comannd with the -provider "Microsoft Enhanced RSA and AES Cryptographic
    Provider" flag.  This took way longer to resolve for me than it should have!  .Net
    4.6 is supposed to resolve this issue.
- id: 276341
  author: Chris
  author_email: chris@cgoosen.com
  author_url: http://www.cgoosen.com
  date: '2018-11-29 10:07:41 +0000'
  date_gmt: '2018-11-29 16:07:41 +0000'
  content: Great info, thanks Aaron.
- id: 277943
  author: Secure Credentials with Self-Signed Certificates for PowerShell Scripts
    | NUTesla | The Informant
  author_email: ''
  author_url: https://monimega.com/blog/2019/01/14/secure-credentials-with-self-signed-certificates-for-powershell-scripts/
  date: '2019-01-14 14:35:28 +0000'
  date_gmt: '2019-01-14 20:35:28 +0000'
  content: "[&#8230;] Using a Certificate to Encrypt Credentials&hellip; [&#8230;]"
- id: 278433
  author: Secure Credentials with Self-Signed Certificates for PowerShell Scripts
    - Microsoft Today
  author_email: ''
  author_url: https://msft.today/secure-credentials-with-self-signed-certificates-for-powershell-scripts/
  date: '2019-01-28 09:37:56 +0000'
  date_gmt: '2019-01-28 15:37:56 +0000'
  content: "[&#8230;] Using a Certificate to Encrypt Credentials&hellip; [&#8230;]"
---
<p>PowerShell is a great way to help automate frequent or repetitive tasks and every now and then these tasks require some form of authentication. You could just store the service account password in the script, but I&rsquo;m really not a fan of doing that and I&rsquo;m sure you&rsquo;d agree it really isn&rsquo;t a very good way to do it. I was working on a script recently which was to be scheduled to run at various times by different service accounts on different servers so I wanted a way to ensure that a single copy of the script could be portable to any server and would still securely connect to Exchange with the correct permissions no matter which service account actually executed the script. Remotely connecting to Exchange/Exchange Online via PowerShell isn&rsquo;t difficult to do and you could just use <em>Get-Credential</em> cmdlet with <em>ConvertFrom-SecureString</em> and <em>Set-Content </em>to securely save your password to file which could then be read by your script without subsequent intervention. The trouble with this solution is that it isn&rsquo;t very portable and that password can only be ready by the user that created the file so it will work great if you used it only on your own machine, but not so well when trying to distribute it to a bunch of servers as a scheduled job. I wanted a solution that would use a particular certificate to decrypt a password stored in the script, in that way if the script was executed on a machine that did not have my certificate installed it would not be able to decrypt the password and would fail. I ended up creating an encrypted password using the public key of a certificate and storing that in the script, the only way to decrypt that password is with the private key of the same certificate. Let&rsquo;s look at this in more detail.</p>
<p>The first component of the solution is a certificate. Since I already had access to a internal Windows CA, I wanted to use a certificate signed by that CA but I also tested it with a self-signed certificate that was generated using &ldquo;makecert.exe&rdquo;. <span style="background-color: #ffffff;">PowerShell 4.0 </span>includes a <a href="https://technet.microsoft.com/en-us/library/hh848633.aspx" target="_blank"><em>New-SelfSignedCertificate</em></a> cmdlet that makes generating a self-signed certificate really easy, but for some reason I wasn&rsquo;t able to use one of those certificates for encryption (more specifically the decryption would not work) and since I planned to use a CA signed certificate anyway I didn&rsquo;t spend a whole lot of time trying to figure it out. The key thing to remember is that you need to install the certificate AND the private key, the certificate doesn&rsquo;t have to be trusted. I decided to create a new certificate template for my &ldquo;Script Authentication&rdquo; certificate by duplicating the &ldquo;Web Server&rdquo; template and making a few changes to it.</p>
<p align="left">Firstly, launch the <span style="background-color: #ffffff;">Certification Authority MMC</span><span style="background-color: #ffffff;">, loca</span>te &ldquo;Certificate Templates&rdquo;, right-click and select &ldquo;Manage&rdquo;</p>
<p align="center"><a href="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture1.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border: 0px;" title="Capture1" src="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture1_thumb.png" alt="Capture1" width="450" height="294" border="0" /></a></p>
<p>Next, locate the &ldquo;Web Server&rdquo; template, right-click and select &ldquo;Duplicate Template&rdquo;</p>
<p align="center"><a href="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture2.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border: 0px;" title="Capture2" src="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture2_thumb.png" alt="Capture2" width="450" height="169" border="0" /></a></p>
<p align="left">I called my new template &ldquo;Script Authentication&rdquo;</p>
<p align="center"><a href="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture3.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border: 0px;" title="Capture3" src="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture3_thumb.png" alt="Capture3" width="504" height="686" border="0" /></a></p>
<p align="left">And you need to ensure that you &ldquo;Allow private key to be exported&rdquo;. Once done, apply those changes.</p>
<p align="center"><a href="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture4.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border: 0px;" title="Capture4" src="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture4_thumb.png" alt="Capture4" width="504" height="686" border="0" /></a></p>
<p align="left">We then need to <span style="background-color: #ffffff;">publish the new template</span> to ensure that it can be used when requesting a new certificate. <span style="background-color: #ffffff;">Right-click</span> &ldquo;Certificate Templates&rdquo;, select &ldquo;New&rdquo; and then &ldquo;Certificate Template to Issue&rdquo; and select your newly created template from the list</p>
<p align="center"><a href="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture5.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border: 0px;" title="Capture5" src="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture5_thumb.png" alt="Capture5" width="550" height="353" border="0" /></a></p>
<p align="left">Once done, you should be able to create and submit an advanced certificate request using the newly created template directly on your CA. You are not required to complete all the fields, but it is useful to give your certificate a descriptive name. I called mine &ldquo;PowerShell Automation&rdquo;.</p>
<p align="center"><a href="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture6.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border: 0px;" title="Capture6" src="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture6_thumb.png" alt="Capture6" width="550" height="810" border="0" /></a></p>
<p>Once you have the installed the certificate, you can export it (don&rsquo;t forget the private key) for use on other machines.</p>
<p align="center"><a href="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture8.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border: 0px;" title="Capture8" src="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture8_thumb.png" alt="Capture8" width="550" height="529" border="0" /></a></p>
<p>I recommend storing it in a safe place and not marking the private key as exportable when moving it around, in this way you have some control over which machines can actually decrypt the password in your script.</p>
<p align="center"><a href="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture9.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border: 0px;" title="Capture9" src="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture9_thumb.png" alt="Capture9" width="550" height="529" border="0" /></a></p>
<p>Here&rsquo;s what my certificate looks like</p>
<p align="center"><a href="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture7.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border: 0px;" title="Capture7" src="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture7_thumb.png" alt="Capture7" width="500" height="622" border="0" /></a></p>
<p>I decided to store my certificate in the computer store, it probably doesn&rsquo;t matter where you store it but you would need to update the following PowerShell cmdlets appropriately. If you are going to have multiple service accounts executing your script, you need to ensure that all these accounts have permission<span style="background-color: #ffff00;"><span style="background-color: #ffffff;"> to read the private key. </span></span><span style="background-color: #ffffff;">This</span> is done by right-clicking the certificate, selecting &ldquo;All Tasks&rdquo; and then &ldquo;Manage Private Keys&rdquo;.</p>
<p>We can use the <em>Get-ChildItem</em> cmdlet to locate our certificate:</p>
<p>[powershell]Get-ChildItem Cert:\LocalMachine\My | Where-Object {$_.Subject -like "CN=PowerShell Automation*"}[/powershell]</p>
<p>Next, I need to encrypt my password. To do this, I define the password as a variable, encode it and then encrypt the encoded password using my certificate&rsquo;s public key:</p>
<p>[powershell]<br />
$Cert = Get-ChildItem Cert:\LocalMachine\My | Where-Object {$_.Subject -like "CN=PowerShell Automation*"}<br />
$Password = 'MyPassword'<br />
$EncodedPwd = [system.text.encoding]::UTF8.GetBytes($Password)<br />
$EncryptedBytes = $Cert.PublicKey.Key.Encrypt($EncodedPwd, $true)<br />
$EncryptedPwd = [System.Convert]::ToBase64String($EncryptedBytes)<br />
[/powershell]</p>
<p><a href="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture10.png"><img style="background-image: none; float: none; padding-top: 0px; padding-left: 0px; margin-left: auto; display: block; padding-right: 0px; margin-right: auto; border: 0px;" title="Capture10" src="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture10_thumb.png" alt="Capture10" width="550" height="195" border="0" /></a></p>
<p>Now that I have the encrypted password, I can store it in my script and decode it using my certificate&rsquo;s private key each time the script is executed. To do this, I pretty much reverse the process:</p>
<p>[powershell]<br />
$EncryptedPwd = "ts32rCLLdZl3/6wINHtLD6bQO65ub&hellip;.. <shortened for simplicity>"<br />
$EncryptedBytes = [System.Convert]::FromBase64String($EncryptedPwd)<br />
$DecryptedBytes = $Cert.PrivateKey.Decrypt($EncryptedBytes, $true)<br />
$DecryptedPwd = [system.text.encoding]::UTF8.GetString($DecryptedBytes)<br />
[/powershell]</p>
<p>You can build this into any scripts you have that currently require credentials, it works great for automating Office 365/Exchange Online scripting. To illustrate this, I put together a quick (and dirty!) script that can be used to provide an automated daily &ldquo;Top Mail Recipient&rdquo; report via email. This script can be scheduled to run daily and it will connect to Exchange Online, generate a list of the top mail recipients and email that report to the address you specify. It&rsquo;s not very useful as it is, but it does show how easily you could automate things using PowerShell and serves as a great example for certificate password encryption.</p>
<p>[powershell]<br />
# Function to create report email<br />
function SendReport{<br />
 $Msg = New-Object Net.Mail.MailMessage<br />
 $Smtp = New-Object Net.Mail.SmtpClient($ExchangeServer)<br />
 $Msg.From = $FromAddress<br />
 $Msg.To.Add($ToAddress)<br />
 $Msg.Subject = "Top Mail Recipient Report for $Date"<br />
 $Msg.Body = $EmailBody<br />
 $Msg.IsBodyHTML = $true<br />
 $Smtp.Send($Msg)<br />
}</p>
<p># Define local Exchange server info for message relay. Ensure that any servers running this script have permission to relay.<br />
$ExchangeServer = "yourexchange.domain.com"<br />
$FromAddress = "Office 365 Reports <reports@yourdomain.com>"<br />
$ToAddress = "you@yourdomain.com"</p>
<p># Some basic HTML styling<br />
$Header = "<br />
<style>"<br />
$Header = $Header + "BODY{background-color:#FFFFFF}"<br />
$Header = $Header + "TABLE{border-width: 1px;border-style: solid;border-color: black;border-collapse: collapse;}"<br />
$Header = $Header + "TH{border-width: 1px;padding: 0px;border-style: solid;border-color: black;background-color:#BDBDBD}"<br />
$Header = $Header + "TD{border-width: 1px;padding: 0px;border-style: solid;border-color: black}"<br />
$Header = $Header + "</style>
<p>"</p>
<p># Connect to Exchange Online<br />
# First decrypt the password using the certificate<br />
$Cert = Get-ChildItem Cert:\LocalMachine\My | Where-Object {$_.Subject -like "CN=PowerShell Automation*"}<br />
$EncryptedPwd = "ts32rCLLdZl3/6wINHtLD6bQO65ubeQ3sHj9zXbhsaQDjihQmdyoja+iL0NGXQX0DicQdXWQRu+P8dSy96ux1tLQR9ZT8WPRq8rHsR3gNXDmipCK/4CHoc5Ki7nbMKUSReprtIrnwjlXZNBocTzurBQ+LtAHvAYipD37AXVjjpwwwqud5HCXk+E4OrJGe+yIx/87neRAunqdKvyuaxUYaxeBdx2R/hpLZhxywinjjVMx+0N2RNk7H3fBEite7uuANcAg+ElAssi4DAQYYDOviIrvbjdpKogKcevAh5xEx4Wm2WBzM5XqXmj1O9TUzB9BOiUVQhDwwqCcUpb2bTNW7g=="<br />
$EncryptedBytes = [System.Convert]::FromBase64String($EncryptedPwd)<br />
$DecryptedBytes = $Cert.PrivateKey.Decrypt($EncryptedBytes, $true)<br />
$DecryptedPwd = [system.text.encoding]::UTF8.GetString($DecryptedBytes) | ConvertTo-SecureString -AsPlainText -Force<br />
# Then define Credentials and create session<br />
$Username = "account@yourdomain.onmicrosoft.com"<br />
$Credential = New-Object System.Management.Automation.PSCredential ($Username,$DecryptedPwd)<br />
$Session = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri https://outlook.office365.com/powershell-liveid/ -Credential $Credential -Authentication Basic -AllowRedirection<br />
Import-PSSession $Session</p>
<p># Generate report data<br />
$Date = Get-Date -DisplayHint Date<br />
$EmailBody = Get-MailTrafficSummaryReport -Category TopMailRecipient | select @{expression={$_.C1};label=&rdquo;User&rdquo;}, @{expression={$_.C2};label=&rdquo;Item Count&rdquo;} | ConvertTo-HTML -head $Header -body "<H2>Top Mail Recipient Report</H2>"</p>
<p># Send report<br />
SendReport<br />
[/powershell]</p>
<p>Here is an example of what the final result looks like:</p>
<p align="center"><a href="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture11.png"><img style="background-image: none; padding-top: 0px; padding-left: 0px; display: inline; padding-right: 0px; border: 0px;" title="Capture11" src="http://www.cgoosen.com/wp-content/uploads/2015/02/Capture11_thumb.png" alt="Capture11" width="600" height="448" border="0" /></a></p>
